/* Great source: https://css-tricks.com/hexagons-and-beyond-flexible-responsive-grid-patterns-sans-media-queries/ */

.gameboard {
  display: grid;
  place-self: center;
  justify-content: center;
}

.box-current-player {
  margin-top: 50px;
  margin-bottom: 50px;
}

.box-current-player > * {
  display: inline;
}

.current-player {
  text-transform: uppercase;
  font-weight: bold;
}

p[data-player='black'] {
  color: black;
}

p[data-player='white'] {
  color: white;
}

.hex-board-frame {
  display: flex;
  /* width of one hexagon  */
  --hexwidth: 30px;
  /* margin around hexagons */
  --hexmargin: 3px;
  /* condensed height equivalent to the height of 2 overlapping hexagons (used to move every second row) */
  --hexcondheight: calc(1.732 * var(--hexwidth) + 4 * var(--hexmargin) - 1px);
  /* additional height of one hexagon compared to its width (to have nice round hexagons)  */
  --hexaddheight: calc(var(--hexwidth) * 0.2885);
  /* last variable `--rows` holds the number of rows and is injected by the template */
}

.hex-board-container {
  /*disable white space between inline block element */
  font-size: 0;
  width: calc((var(--rows) * 1.5) * (var(--hexwidth) + 2 * var(--hexmargin)));
  padding-bottom: calc(var(--hexaddheight) * 2);
  padding-top: calc(var(--hexaddheight) * 2);
}

.hex-board-container div {
  width: var(--hexwidth);
  margin: var(--hexmargin);
  height: calc(var(--hexwidth) * 1.1547);
  display: inline-block;
  clip-path: polygon(0% 25%, 0% 75%, 50% 100%, 100% 75%, 100% 25%, 50% 0%);
  margin-bottom: calc(var(--hexmargin) - var(--hexaddheight));
}

.hex-board-container form {
  display: inline-block;
}

.hex-board-container::before,
.hex-board-container i {
  content: '';
  width: calc((var(--hexwidth) + 2 * var(--hexmargin)) * ((var(--rows)) / 2));
  float: left;
  height: calc(
    (var(--hexcondheight) * (var(--rows)) / 2) + var(--hexaddheight)
  );
  shape-outside: linear-gradient(to top right, #000 50%, #0000 0);
}

.hex-board-container i {
  float: right;
  shape-outside: linear-gradient(
    to bottom left,
    #000 calc(50% - 1 * var(--hexwidth)),
    #0000 0
  );
}

.top-edge,
.bottom-edge,
.left-edge,
.right-edge {
  position: absolute;
  width: calc((var(--hexwidth) + 2 * var(--hexmargin)) * (var(--rows)));
  height: calc(var(--hexaddheight) * 2);
  clip-path: polygon(2% 0%, 98% 0%, 100% 50%, 98% 100%, 2% 100%, 0% 50%);
}

.top-edge {
  background: white;
  transform: translate(
    calc(var(--hexwidth) / 2),
    calc(0px - 2 * var(--hexmargin))
  );
}

.bottom-edge {
  background: white;
  transform: translate(
    calc(
      (var(--hexwidth) + 2 * var(--hexmargin)) * ((var(--rows) - 1) / 2) +
        var(--hexwidth) / 1.5
    ),
    calc(
      var(--hexcondheight) * var(--rows) / 2 + var(--hexwidth) / 1.5 +
        var(--hexaddheight) * 2
    )
  );
}

.left-edge {
  background: black;
  transform-origin: left;
  transform: rotate(60deg)
    translate(
      calc(0px - 2 * var(--hexmargin) + var(--hexwidth) / 2),
      calc(var(--hexaddheight) * 2.5)
    );
}

.right-edge {
  background: black;
  transform-origin: right;
  transform: rotate(240deg)
    translate(
      calc(0px - 2 * var(--hexmargin) - var(--hexwidth) / 1.5),
      calc(0px - var(--hexaddheight) * 2 + var(--hexwidth) / 0.9)
    );
}

.cell[data-color='empty'] {
  background: #eea;
  cursor: pointer;
}

.cell[data-color='black'] {
  background: black;
}

.cell[data-color='white'] {
  background: white;
}

.cell[data-color='empty']:hover {
  background: red;
}
